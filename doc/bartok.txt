-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Bartok is a card game where it is possible to change the rules.
--   
--   This library contains functions to allow players to build their own
--   rules.
--   
--   When implementing rules, they should be well behaved, and interact
--   well with other well behaved rules:
--   
--   The set of players must not be modified (except on <a>PlayerJoin</a>).
--   They may be rearranged, which will affect turn order but not seating
--   order (so a change to turn order is not immediately obvious to
--   players).
--   
--   A rule should call either the inner ruleset or <a>illegal</a> with the
--   event it was passed and a potentially modified GameState
--   
--   If a rule awards penalty cards, this must occur before invoking the
--   inner rules. A rule is allowed to call the inner rules multiple times
--   to work out whether a penatly should be awarded, but should add
--   penalty cards to the original state, then call the inner rule again
--   before returning.
@package bartok
@version 0.0.0.1


-- | Datatypes for cards, game state and game view alongside some basic
--   functions to process them.
module DataTypes

-- | The type of transformations of game state
type Step = GameState -> GameState

-- | This is the type of games (meaning a ruleset, rather than a specific
--   instance of a game). Given an event such as a player action, and a
--   game state, it returns the resulting state
type Game = Event -> Step

-- | The type of rules - a rule is added by function composition forming a
--   chain such as 'r3 (r1 (r2 baseAct))' . Most rules should call the
--   first argument under most circumstances and usually without changing
--   the event.
--   
--   Game -&gt; Game == (Event -&gt; GameState -&gt; GameState) -&gt; Event
--   -&gt; GameState -&gt; GameState
type Rule = Game -> Game

-- | Names of players.
type Name = String

-- | At any point, a player can attempt to take one of these actions
data Action
Draw :: Int -> Action
Play :: Card -> Action

-- | Events that rules should be able to deal with
data Event

-- | A player requesting to join the game. This is not limited to the start
PlayerJoin :: Name -> (Maybe (Name, Name)) -> Event

-- | A player performing one of the above actions and sending a message.
Action :: Name -> Action -> String -> Event

-- | If no player has made an action for 10 seconds, this event will be
--   sent
Timeout :: Event

-- | The state of a game in play
data GameState
GS :: [Name] -> Map Name Hand -> [Card] -> NonEmpty Card -> [String] -> Bool -> StdGen -> Maybe Name -> Map VarName Int -> GameState

-- | The players curretly in the game. The player whose turn it is should
--   be at head of list and usually this advances forward by 1 each turn.
[_players] :: GameState -> [Name]

-- | Stores the contents of each player's hand
[_hands] :: GameState -> Map Name Hand

-- | The deck from which cards are drawn
[_deck] :: GameState -> [Card]

-- | The cards that have been played -
[_pile] :: GameState -> NonEmpty Card

-- | The messages that . Contains only those generated by the most recent
--   event.
[_messages] :: GameState -> [String]

-- | Indicates if the last move was successful. This should be true When a
--   new event happens, this is False until baseAct is called. _prevGS ::
--   Maybe (GameState,Action),
[_lastMoveLegal] :: GameState -> Bool

-- | A seeded random number generator so that you can
[_randg] :: GameState -> StdGen

-- | <tt>Nothing</tt> until a player p wins at which point it becomes
--   <tt>Just p</tt>
[_winner] :: GameState -> Maybe Name

-- | A store of named variables that rules may use to keep track of state
--   between events.
[_varMap] :: GameState -> Map VarName Int

-- | Construct a new game from a list of player names.
newGame :: [String] -> GameState

-- | An ordered collection of cards forming a player's hand
type Hand = [Card]

-- | A single playing card
type Card = (Rank, Suit)
data Suit
Clubs :: Suit
Diamonds :: Suit
Hearts :: Suit
Spades :: Suit
data Rank
Ace :: Rank
Two :: Rank
Three :: Rank
Four :: Rank
Five :: Rank
Six :: Rank
Seven :: Rank
Eight :: Rank
Nine :: Rank
Ten :: Rank
Jack :: Rank
Knight :: Rank
Queen :: Rank
King :: Rank

-- | Get the suit of a card.
suit :: Card -> Suit

-- | Get the rank of a card.
rank :: Card -> Rank
type VarName = String
setVar :: VarName -> Int -> Step

-- | variable processing
readVar :: VarName -> GameState -> Int
modifyVar :: VarName -> (Int -> Int) -> Step

-- | Shuffle the deck (does not touch the pile or hands) using the random
--   seed contained in GameState.
shuffleDeck :: Step

-- | Get the playeer if an event
eventPlayer :: Event -> Maybe Name

-- | Functions to tell a player what they should see
type Viewer = Name -> GameState -> GameView

-- | Rules that modify what players see without affecting the game state
type ViewRule = Viewer -> Viewer

-- | A card as viewed - the type of cards sent to the client
data CardView
CardFace :: Card -> CardView
CardBack :: CardView

-- | The structure describing data seen by players
data GameView
GV :: [(Name, [CardView])] -> [CardView] -> [CardView] -> [String] -> GameView

-- | The players and the information a particular player will have about
--   each hand. By default, this is a <a>CardFace</a>s for the viewing
--   player and a number of <a>CardBack</a>s for others.
[_handsV] :: GameView -> [(Name, [CardView])]

-- | What should be seen of the pile. By default, only the top card is
--   visible.
[_pileV] :: GameView -> [CardView]

-- | What should be seen of the pile. By default, none are visible.
[_deckV] :: GameView -> [CardView]

-- | The messages a player can see. By default, this is all messages that
--   have been sent
[_messagesV] :: GameView -> [String]

-- | Complex rules
type Rule' = (Rule, ViewRule)

-- | Get the unicode playing card character corresponding to some card
uniCard :: Card -> Char
type Parser = StateT String Maybe
runParser :: Parser a -> String -> Maybe a
parseSuit :: Parser Suit
parseRank :: Parser Rank
parseCard :: Parser Card
if' :: Bool -> a -> a -> a
(/\) :: (Functor f) => ((a -> (a, a)) -> (c -> (a, c))) -> ((b -> (b, b)) -> (c -> (b, c))) -> (((a, b) -> f (a, b)) -> (c -> f c))
infixl 7 /\
players :: Lens' GameState [Name]
hands :: Lens' GameState (Map Name Hand)
deck :: Lens' GameState [Card]
pile :: Lens' GameState (NonEmpty Card)
messages :: Lens' GameState [String]
lastMoveLegal :: Lens' GameState Bool
randg :: Lens' GameState StdGen
winner :: Lens' GameState (Maybe Name)
varMap :: Lens' GameState (Map VarName Int)
handsV :: Lens' GameView [(Name, [CardView])]
pileV :: Lens' GameView [CardView]
deckV :: Lens' GameView [CardView]
messagesV :: Lens' GameView [String]
instance GHC.Enum.Enum DataTypes.Rank
instance (GHC.Enum.Enum a, GHC.Enum.Enum b, GHC.Enum.Bounded a, GHC.Enum.Bounded b, GHC.Classes.Eq a, GHC.Classes.Eq b) => GHC.Enum.Enum (a, b)
instance GHC.Show.Show DataTypes.GameView
instance GHC.Show.Show DataTypes.CardView
instance GHC.Show.Show DataTypes.GameState
instance GHC.Classes.Eq DataTypes.Event
instance GHC.Show.Show DataTypes.Event
instance GHC.Classes.Eq DataTypes.Action
instance GHC.Show.Show DataTypes.Action
instance GHC.Classes.Ord DataTypes.Rank
instance GHC.Enum.Bounded DataTypes.Rank
instance GHC.Classes.Eq DataTypes.Rank
instance GHC.Show.Show DataTypes.Rank
instance GHC.Classes.Ord DataTypes.Suit
instance GHC.Enum.Bounded DataTypes.Suit
instance GHC.Enum.Enum DataTypes.Suit
instance GHC.Classes.Eq DataTypes.Suit
instance GHC.Show.Show DataTypes.Suit


-- | The functions in this module define how the data sent to clients is
--   constructed. They should help when writing rules that affect what
--   players can see.
module Views

-- | Functions to tell a player what they should see
type Viewer = Name -> GameState -> GameView

-- | Rules that modify what players see without affecting the game state
type ViewRule = Viewer -> Viewer

-- | Like <tt>baseGame</tt>, this defines how cards should be viewed in a
--   very simple game. See <a>GameView</a> for more.
baseViewer :: Viewer

-- | The structure describing data seen by players
data GameView
GV :: [(Name, [CardView])] -> [CardView] -> [CardView] -> [String] -> GameView

-- | The players and the information a particular player will have about
--   each hand. By default, this is a <a>CardFace</a>s for the viewing
--   player and a number of <a>CardBack</a>s for others.
[_handsV] :: GameView -> [(Name, [CardView])]

-- | What should be seen of the pile. By default, only the top card is
--   visible.
[_pileV] :: GameView -> [CardView]

-- | What should be seen of the pile. By default, none are visible.
[_deckV] :: GameView -> [CardView]

-- | The messages a player can see. By default, this is all messages that
--   have been sent
[_messagesV] :: GameView -> [String]

-- | Hide the last card in a player's hand.
lastCard :: ViewRule

-- | Hides other players' hands.
onlyOwnCards :: ViewRule

-- | <tt>baseView</tt> with the above rules added to it.
defaultView :: Viewer

-- | Modify a player's view of their own hand
mapOwnHand :: ([CardView] -> [CardView]) -> ViewRule

-- | Modify the view of all other players' hands
mapOtherHands :: ([CardView] -> [CardView]) -> ViewRule

-- | Apply a modification to the structure describing what can be seen of
--   each player's hand after inner rules have been applied.
modifyHandMap :: ([(Name, [CardView])] -> [(Name, [CardView])]) -> ViewRule

-- | Apply a function to all views of hands
mapHands :: ([CardView] -> [CardView]) -> ViewRule
hideHand :: [CardView] -> [CardView]


-- | This contains functions for a simple game.
module BaseGame
doNothing :: Step
fromStep :: Step -> Game
if'' :: Bool -> (a -> a) -> (a -> a)
(%) :: String -> String -> String
(%%) :: String -> Card -> String

-- | Returns a game where the move has not occured and a penalty has been
--   given. Should be used with <tt>doOnly</tt>
illegal :: Int -> String -> Game

-- | A penalty which does not end the turn
penalty :: Int -> String -> Name -> Step

-- | Broadcast a message while identifying the player it came from.
broadcastp :: Name -> String -> Step

-- | Broadcast the message a player sent with their action.
sayAct :: Game

-- | Add a player to the game
addPlayer :: Name -> Maybe (Name, Name) -> Step
addToSeat :: Name -> Maybe (Name, Name) -> [Name] -> [Name]

-- | Play a move and tidy up the game state.
play :: Name -> Event -> Card -> Step

-- | The default behaviour. Draws always succeed, a card may be played if
--   it is in the player's hand, it is the player's turn and it matches
--   either the suit or rank of the previous card. Timeouts give one
--   penalty card to the player whose turn it is.
baseAct :: Game

-- | Add a message to the list of messages. Will be seen by all players by
--   default.
broadcast :: String -> Step

-- | Move n cards from the deck to a player's hand
draw :: Int -> Name -> Step

-- | Get the hand of the current player.
getHand :: Name -> GameState -> Maybe Hand

-- | Move a single card from the deck to a player's hand.
draw1 :: Name -> Step

-- | If any players have more than their share of cards, give return them
--   to the deck (so that players can always draw cards and be given
--   penalties).
taxes :: Step

-- | Remove the top card of the deck shuffling the pile back in and
--   applying taxes if necessary.
cardFromDeck :: GameState -> (Card, GameState)

-- | Put a card on the pile
cardToPile :: Card -> Step

-- | Remove a card from a players hand.
cardFromHand' :: Name -> Card -> Step

-- | Test if it is a player's turn.
isTurn :: Name -> GameState -> Bool

-- | Advance the turn order by one.
nextTurn :: Step

-- | incomplete?
win :: Name -> Step

module RuleHelpers
when :: (a -> Bool) -> Rule -> a -> Rule
with :: (Event -> GameState -> a) -> (a -> Rule) -> Rule
with' :: (Event -> GameState -> a) -> (a -> Game) -> Game
when' :: (a -> Bool) -> Game -> a -> Game
doAfter :: Game -> Rule
doBefore :: Game -> Rule
doOnly :: Game -> Rule

-- | player's next action must be the given one how do I make require
--   actions for something other than a single
regexProcess :: String -> Regex
split :: String -> [String]
reconstitute :: [String] -> String
findInMs :: String -> String -> Bool
removeIn :: String -> String -> (Bool, String)
removeIn' :: String -> String -> (Maybe String, String)
removeIn'' :: Regex -> [String] -> [String] -> (Maybe String, [String], [String])
removeAll :: String -> String -> ([String], String)
removeAllN :: String -> String -> (Int, String)
removeAll' :: Regex -> ([String], [String]) -> [String] -> ([String], [String])
mustSay :: String -> Game
mustSay' :: String -> Event -> (Event, Step)
said :: String -> String -> Bool
banPhrase :: Int -> String -> ((Name, Action, String) -> GameState -> Bool) -> Rule
require :: (Name, Action, String) -> (Bool -> Game) -> Rule
onPlay :: (Card -> Rule) -> Rule
onLegalCard :: (Card -> Game) -> Rule
onAction :: ((Name, Action, String) -> Rule) -> Rule
onDraw :: ((Name, Int) -> Rule) -> Rule

-- | Advance the turn order by one.
nextTurn :: Step
doNothing :: Step

-- | Returns a game where the move has not occured and a penalty has been
--   given. Should be used with <tt>doOnly</tt>
illegal :: Int -> String -> Game

-- | Add a message to the list of messages. Will be seen by all players by
--   default.
broadcast :: String -> Step

-- | Broadcast a message while identifying the player it came from.
broadcastp :: Name -> String -> Step

-- | A penalty which does not end the turn
penalty :: Int -> String -> Name -> Step

-- | Test if it is a player's turn.
isTurn :: Name -> GameState -> Bool

-- | incomplete?
win :: Name -> Step

-- | Move n cards from the deck to a player's hand
draw :: Int -> Name -> Step

module Rules
r8 :: Rule
reverseDirection :: Step
rq :: Rule
rlast :: Rule
rMao :: Rule
(^.^) :: (Event -> b -> c) -> (Event -> a -> b) -> Event -> a -> c
(^^.^^) :: (Bool -> Event -> b -> c) -> (Bool -> Event -> a -> b) -> Bool -> Event -> a -> c
ifSaid :: String -> Game -> Game
getState :: Event -> GameState -> GameState
rMao'' :: Rule
r7' :: Rule
defaultRules :: [Rule]
defaultRulesNamed :: [([Char], Rule)]


-- | Look at the implementation of these to see examples of how to write
--   rules
module Sample

-- | When an 8 is played, skip the following player's turn
r8 :: Rule
reverseDirection :: Step

-- | Reverse direction when a Queen is played
rq :: Rule
mustdo7 :: Int -> (Bool -> Game) -> Rule
count7s :: GameState -> Int

-- | When a seven is played, the player must say 'have a nice day'. The
--   following player must either play another seven, saying 'have a very
--   nice day' or say 'thank you' and draw 2 cards. If futher sevens are
--   played (each such player must add another <tt>very</tt>), the first
--   player who cannot play one must say 'thank you very{n} much' and draw
--   2n cards.
r7 :: Rule
r7' :: Rule
rC :: Game -> Game
gSnap :: Rule'
nextTurnDo :: String -> (Game -> Event -> GameState -> Bool) -> Rule -> Rule
nextTurnDoUntil :: String -> (Game -> Event -> GameState -> Bool) -> (Game -> Event -> GameState -> (GameState, Bool)) -> Rule
r6 :: Rule
rPM :: Rule
rPMV :: ViewRule
rPM' :: Rule'
rBlind :: Rule
rBlindV :: ViewRule
rBlind' :: Rule'
run7 :: Int -> Rule


-- | This approaches monads, but we aren't using those. This presents
--   operations with
module TLib

-- | Avoids extremely long types. Almost a Monad.
type GEGSto a = Game  The inner ruleset -> Event  The event under consideration -> GameState  The previous state of the game -> a

-- | When an action happens, do something with it
withAction :: (Action -> Rule) -> Rule

-- | When an action happens, do something with the message that gets sent
withMessage :: (String -> Rule) -> Rule

-- | Build a rule (or similar that depends on an extracted value (if you
--   know monads, this is bind <tt>(&gt;&gt;=)</tt>).
--   
--   e.g. <tt>with (<a>getVar</a> "n") ( n -&gt;
--   doSomethingInvolvingN)</tt>
--   
--   e.g. &gt; with (<a>getVar</a> "n") ( n -&gt; doSomethingInvolvingN)
with :: GEGSto a -> (a -> GEGSto b) -> GEGSto b

-- | Given a condition, implement a rule only when that condition holds.
when :: (GEGSto Bool) -> Rule -> Rule

-- | Given a condition, do one thing when the condition holds and another
--   when it doesn't.
whether :: (GEGSto Bool) -> Rule -> Rule -> Rule

-- | Given a fresh variable name, when a condition is met, run an action on
--   the following turn.
onNextTurn :: VarName -> (GEGSto Bool) -> Rule -> Rule

-- | Upon a condition being satisfied, implement a rule until a second
--   condition is satisfied.
uponDoUntil :: VarName -> GEGSto Bool -> Rule -> GEGSto Bool -> Rule

-- | lift an action (monadic <a>fmap</a>)
(.:) :: (a -> b) -> GEGSto a -> GEGSto b

-- | Abbreviation for _ _ _ -&gt;
__ :: a -> GEGSto a

-- | Returns True if the event is an Action.
isAction :: GEGSto Bool

-- | Returns True if the event is an action and is legal under the inner
--   ruleset.
isLegal :: GEGSto Bool

-- | Returns True if the event is an action and the next Turn should be
--   taken by the player submitting it.
isTurn :: GEGSto Bool

-- | Returns True if the event is an action which satisfies the condition.
actionIs :: (Action -> Bool) -> GEGSto Bool

-- | Returns True if the event is a Play action and the card satisfies the
--   condition.
cardIs :: (Card -> Bool) -> GEGSto Bool

-- | Returns True if the value of the named variable is not 0.
boolVar :: VarName -> GEGSto Bool

-- | Tests if a player said something matching a given regex (case
--   insenstive). Like most string processing functions in this project,
--   this separates input messages based on semicolons.
said :: String -> GEGSto Bool

-- | Combines 2 tests. Returns True if both do.
(~&~) :: GEGSto Bool -> GEGSto Bool -> GEGSto Bool

-- | Negates a test. Be aware that <tt>(not_ (actionIs (==(Draw 2))))</tt>
--   is different from <tt>(actionIs (/=(Draw 2)))</tt>. The first example
--   would return True for events that are not actions.
not_ :: GEGSto Bool -> GEGSto Bool

-- | Retrive a variable from the GameState.
getVar :: String -> GEGSto Int

-- | Extract the state argument.
state :: GEGSto GameState

-- | The penalty message produced by <tt>mustSay s</tt>
failmsg :: String -> String

-- | penalize if <tt>s</tt> is not said
mustSay :: String -> Rule

-- | Penalize for unnecessarily saying something. This works by testing if
--   the absence of any matching component of a player's message would
--   cause a penalty containing <a>failmsg</a>. If not, the component is
--   assumed to be unnecessary.
unnec :: String -> Rule

-- | If the condition holds, require that they say the message; otherwise,
--   penalize them if they say it
sometimesSay :: String -> GEGSto Bool -> Rule

-- | Any action except the specified one is an illegal move. When the
--   specified action occurs, run the second argument.
mustDo :: Action -> Rule -> Rule

-- | Transform the list of players (affects turn order).
modifyPlayers :: ([Name] -> [Name]) -> Step

-- | A class for types that are <tt>smaller</tt> than <a>Rule</a> so that
--   there are different options for how to convert.
class Ruleable a
doAfter :: Ruleable a => a -> Rule
doBefore :: Ruleable a => a -> Rule
doOnly :: Ruleable a => a -> Rule

-- | The type of transformations of game state
type Step = GameState -> GameState

-- | This is the type of games (meaning a ruleset, rather than a specific
--   instance of a game). Given an event such as a player action, and a
--   game state, it returns the resulting state
type Game = Event -> Step

-- | The type of rules - a rule is added by function composition forming a
--   chain such as 'r3 (r1 (r2 baseAct))' . Most rules should call the
--   first argument under most circumstances and usually without changing
--   the event.
--   
--   Game -&gt; Game == (Event -&gt; GameState -&gt; GameState) -&gt; Event
--   -&gt; GameState -&gt; GameState
type Rule = Game -> Game

-- | The state of a game in play
data GameState

-- | Events that rules should be able to deal with
data Event

-- | A player requesting to join the game. This is not limited to the start
PlayerJoin :: Name -> (Maybe (Name, Name)) -> Event

-- | A player performing one of the above actions and sending a message.
Action :: Name -> Action -> String -> Event

-- | If no player has made an action for 10 seconds, this event will be
--   sent
Timeout :: Event

-- | At any point, a player can attempt to take one of these actions
data Action
Draw :: Int -> Action
Play :: Card -> Action

-- | Names of players.
type Name = String

-- | A single playing card
type Card = (Rank, Suit)

-- | A card as viewed - the type of cards sent to the client
data CardView
CardFace :: Card -> CardView
CardBack :: CardView

-- | The structure describing data seen by players
data GameView
GV :: [(Name, [CardView])] -> [CardView] -> [CardView] -> [String] -> GameView

-- | The players and the information a particular player will have about
--   each hand. By default, this is a <a>CardFace</a>s for the viewing
--   player and a number of <a>CardBack</a>s for others.
[_handsV] :: GameView -> [(Name, [CardView])]

-- | What should be seen of the pile. By default, only the top card is
--   visible.
[_pileV] :: GameView -> [CardView]

-- | What should be seen of the pile. By default, none are visible.
[_deckV] :: GameView -> [CardView]

-- | The messages a player can see. By default, this is all messages that
--   have been sent
[_messagesV] :: GameView -> [String]

-- | Get the suit of a card.
suit :: Card -> Suit

-- | Get the rank of a card.
rank :: Card -> Rank
data Suit
Clubs :: Suit
Diamonds :: Suit
Hearts :: Suit
Spades :: Suit
data Rank
Ace :: Rank
Two :: Rank
Three :: Rank
Four :: Rank
Five :: Rank
Six :: Rank
Seven :: Rank
Eight :: Rank
Nine :: Rank
Ten :: Rank
Jack :: Rank
Knight :: Rank
Queen :: Rank
King :: Rank

-- | Functions to tell a player what they should see
type Viewer = Name -> GameState -> GameView

-- | Rules that modify what players see without affecting the game state
type ViewRule = Viewer -> Viewer

-- | variable processing
readVar :: VarName -> GameState -> Int
setVar :: VarName -> Int -> Step
modifyVar :: VarName -> (Int -> Int) -> Step

-- | Advance the turn order by one.
nextTurn :: Step

-- | Move n cards from the deck to a player's hand
draw :: Int -> Name -> Step

-- | Add a message to the list of messages. Will be seen by all players by
--   default.
broadcast :: String -> Step
(%) :: String -> String -> String
instance TLib.Ruleable DataTypes.Step
instance TLib.Ruleable DataTypes.Game


-- | Looking at the source code is recommended
module TSample
r7 :: Rule
r8 :: Rule
rq :: Rule
rSpade :: Rule
