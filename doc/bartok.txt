-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Bartok is a card game where it is possible to change the rules.
--   
--   This library contains functions to allow players to build their own
--   rules.
--   
--   When implementing rules, they should be well behaved, and interact
--   well with other well behaved rules:
--   
--   The set of players must not be modified (except on <a>PlayerJoin</a>
--   or <a>PlayerLeave</a>). They may be rearranged, which will affect turn
--   order but not seating order (so a change to turn order is not
--   immediately obvious to players).
--   
--   A rule should call either the inner ruleset or <a>illegal</a> with the
--   event it was passed and a potentially modified GameState
--   
--   If a rule awards penalty cards, this must occur before invoking the
--   inner rules. A rule is allowed to call the inner rules multiple times
--   to work out whether a penatly should be awarded, but should add
--   penalty cards to the original state, then call the inner rule again
--   before returning.
@package bartok
@version 0.1.0.1


-- | Datatypes for cards, game state and game view alongside some basic
--   functions to process them.
module Game.Bartok.DataTypes

-- | The type of transformations of game state
type Step = GameState -> GameState

-- | This is the type of games (meaning a ruleset, rather than a specific
--   instance of a game). Given an event such as a player action, and a
--   game state, it returns the resulting state
type Game = Event -> Step

-- | The type of rules - a rule is added by function composition forming a
--   chain such as 'r3 (r1 (r2 baseAct))' . Most rules should call the
--   first argument under most circumstances and usually without changing
--   the event.
--   
--   Game -&gt; Game == (Event -&gt; GameState -&gt; GameState) -&gt; Event
--   -&gt; GameState -&gt; GameState
type Rule = Game -> Game

-- | Names of players.
type Name = String

-- | At any point, a player can attempt to take one of these actions
data Action
Draw :: Int -> Action
Play :: Card -> Action

-- | Events that rules should be able to deal with
data Event

-- | A player leaving the game
PlayerLeave :: Name -> Event

-- | A player requesting to join the game. This is not limited to the start
PlayerJoin :: Name -> Maybe (Name, Name) -> Event

-- | A player performing one of the above actions and sending a message.
Action :: Name -> Action -> String -> Event

-- | If no player has made an action for 10 seconds, this event will be
--   sent
Timeout :: Event

-- | The state of a game in play
data GameState
GS :: [Name] -> Map Name Hand -> [Card] -> NonEmpty Card -> [String] -> Bool -> StdGen -> Maybe Name -> Map VarName Int -> GameState

-- | The players curretly in the game. The player whose turn it is should
--   be at head of list and usually this advances forward by 1 each turn.
[_players] :: GameState -> [Name]

-- | Stores the contents of each player's hand
[_hands] :: GameState -> Map Name Hand

-- | The deck from which cards are drawn
[_deck] :: GameState -> [Card]

-- | The cards that have been played -
[_pile] :: GameState -> NonEmpty Card

-- | The messages that . Contains only those generated by the most recent
--   event.
[_messages] :: GameState -> [String]

-- | Indicates if the last move was successful. This should be true When a
--   new event happens, this is False until baseAct is called. _prevGS ::
--   Maybe (GameState,Action),
[_lastMoveLegal] :: GameState -> Bool

-- | A seeded random number generator so that you can
[_randg] :: GameState -> StdGen

-- | <tt>Nothing</tt> until a player p wins at which point it becomes
--   <tt>Just p</tt>
[_winner] :: GameState -> Maybe Name

-- | A store of named variables that rules may use to keep track of state
--   between events.
[_varMap] :: GameState -> Map VarName Int

-- | Construct a new game from a list of player names.
newGame :: [String] -> GameState

-- | An ordered collection of cards forming a player's hand
type Hand = [Card]

-- | A single playing card
type Card = (Rank, Suit)
data Suit
Clubs :: Suit
Diamonds :: Suit
Hearts :: Suit
Spades :: Suit
data Rank
Ace :: Rank
Two :: Rank
Three :: Rank
Four :: Rank
Five :: Rank
Six :: Rank
Seven :: Rank
Eight :: Rank
Nine :: Rank
Ten :: Rank
Jack :: Rank
Knight :: Rank
Queen :: Rank
King :: Rank

-- | Get the suit of a card.
suit :: Card -> Suit

-- | Get the rank of a card.
rank :: Card -> Rank
type VarName = String
setVar :: VarName -> Int -> Step

-- | variable processing
readVar :: VarName -> GameState -> Int
modifyVar :: VarName -> (Int -> Int) -> Step

-- | Shuffle the deck (does not touch the pile or hands) using the random
--   seed contained in GameState.
shuffleDeck :: Step

-- | Get the player of an event
eventPlayer :: Event -> Maybe Name

-- | Functions to tell a player what they should see
type Viewer = Name -> GameState -> GameView

-- | Rules that modify what players see without affecting the game state
type ViewRule = Viewer -> Viewer

-- | A card as viewed - the type of cards sent to the client
data CardView
CardFace :: Card -> CardView
CardBack :: CardView

-- | The structure describing data seen by players
data GameView
GV :: [(Name, [CardView])] -> [CardView] -> [CardView] -> [String] -> GameView

-- | The players and the information a particular player will have about
--   each hand. By default, this is a <a>CardFace</a>s for the viewing
--   player and a number of <a>CardBack</a>s for others.
[_handsV] :: GameView -> [(Name, [CardView])]

-- | What should be seen of the pile. By default, only the top card is
--   visible.
[_pileV] :: GameView -> [CardView]

-- | What should be seen of the pile. By default, none are visible.
[_deckV] :: GameView -> [CardView]

-- | The messages a player can see. By default, this is all messages that
--   have been sent
[_messagesV] :: GameView -> [String]

-- | Complex rules
type Rule' = (Rule, ViewRule)

-- | Get the unicode playing card character corresponding to some card
uniCard :: Card -> Char
type Parser = StateT String Maybe
runParser :: Parser a -> String -> Maybe a
parseSuit :: Parser Suit
parseRank :: Parser Rank
parseCard :: Parser Card

-- | Non-empty (and non-strict) list type.
data NonEmpty a
(:|) :: a -> [a] -> NonEmpty a
infixr 5 :|

-- | A Map from keys <tt>k</tt> to values <tt>a</tt>.
data Map k a

-- | The <a>StdGen</a> instance of <a>RandomGen</a> has a <a>genRange</a>
--   of at least 30 bits.
--   
--   The result of repeatedly using <a>next</a> should be at least as
--   statistically robust as the <i>Minimal Standard Random Number
--   Generator</i> described by [<a>System.Random\#Park</a>,
--   <a>System.Random\#Carta</a>]. Until more is known about
--   implementations of <a>split</a>, all we require is that <a>split</a>
--   deliver generators that are (a) not identical and (b) independently
--   robust in the sense just given.
--   
--   The <a>Show</a> and <a>Read</a> instances of <a>StdGen</a> provide a
--   primitive way to save the state of a random number generator. It is
--   required that <tt><a>read</a> (<a>show</a> g) == g</tt>.
--   
--   In addition, <a>reads</a> may be used to map an arbitrary string (not
--   necessarily one produced by <a>show</a>) onto a value of type
--   <a>StdGen</a>. In general, the <a>Read</a> instance of <a>StdGen</a>
--   has the following properties:
--   
--   <ul>
--   <li>It guarantees to succeed on any string.</li>
--   <li>It guarantees to consume only a finite portion of the string.</li>
--   <li>Different argument strings are likely to result in different
--   results.</li>
--   </ul>
data StdGen

-- | Takes a range <i>(lo,hi)</i> and a random number generator <i>g</i>,
--   and returns a random value uniformly distributed in the closed
--   interval <i>[lo,hi]</i>, together with a new generator. It is
--   unspecified what happens if <i>lo&gt;hi</i>. For continuous types
--   there is no requirement that the values <i>lo</i> and <i>hi</i> are
--   ever produced, but they may be, depending on the implementation and
--   the interval.
randomR :: (Random a, RandomGen g) => (a, a) -> g -> (a, g)

-- | The same as <a>randomR</a>, but using a default range determined by
--   the type:
--   
--   <ul>
--   <li>For bounded types (instances of <a>Bounded</a>, such as
--   <a>Char</a>), the range is normally the whole type.</li>
--   <li>For fractional types, the range is normally the semi-closed
--   interval <tt>[0,1)</tt>.</li>
--   <li>For <a>Integer</a>, the range is (arbitrarily) the range of
--   <a>Int</a>.</li>
--   </ul>
random :: (Random a, RandomGen g) => g -> (a, g)
if' :: Bool -> a -> a -> a
(/\) :: Functor f => ((a -> (a, a)) -> c -> (a, c)) -> ((b -> (b, b)) -> c -> (b, c)) -> ((a, b) -> f (a, b)) -> c -> f c
infixl 7 /\
players :: Lens' GameState [Name]
hands :: Lens' GameState (Map Name Hand)
deck :: Lens' GameState [Card]
pile :: Lens' GameState (NonEmpty Card)
messages :: Lens' GameState [String]
lastMoveLegal :: Lens' GameState Bool
randg :: Lens' GameState StdGen
winner :: Lens' GameState (Maybe Name)
varMap :: Lens' GameState (Map VarName Int)
handsV :: Lens' GameView [(Name, [CardView])]
pileV :: Lens' GameView [CardView]
deckV :: Lens' GameView [CardView]
messagesV :: Lens' GameView [String]
instance GHC.Enum.Enum Game.Bartok.DataTypes.Rank
instance (GHC.Enum.Enum a, GHC.Enum.Enum b, GHC.Enum.Bounded a, GHC.Enum.Bounded b, GHC.Classes.Eq a, GHC.Classes.Eq b) => GHC.Enum.Enum (a, b)
instance GHC.Show.Show Game.Bartok.DataTypes.GameView
instance GHC.Show.Show Game.Bartok.DataTypes.CardView
instance GHC.Show.Show Game.Bartok.DataTypes.GameState
instance GHC.Classes.Eq Game.Bartok.DataTypes.Event
instance GHC.Show.Show Game.Bartok.DataTypes.Event
instance GHC.Classes.Eq Game.Bartok.DataTypes.Action
instance GHC.Show.Show Game.Bartok.DataTypes.Action
instance GHC.Classes.Ord Game.Bartok.DataTypes.Rank
instance GHC.Enum.Bounded Game.Bartok.DataTypes.Rank
instance GHC.Classes.Eq Game.Bartok.DataTypes.Rank
instance GHC.Show.Show Game.Bartok.DataTypes.Rank
instance GHC.Classes.Ord Game.Bartok.DataTypes.Suit
instance GHC.Enum.Bounded Game.Bartok.DataTypes.Suit
instance GHC.Enum.Enum Game.Bartok.DataTypes.Suit
instance GHC.Classes.Eq Game.Bartok.DataTypes.Suit
instance GHC.Show.Show Game.Bartok.DataTypes.Suit


-- | This contains functions for a simple game.
module Game.Bartok.BaseGame
doNothing :: Step
fromStep :: Step -> Game
if'' :: Bool -> (a -> a) -> a -> a
(%) :: String -> String -> String
(%%) :: String -> Card -> String
appendl :: NonEmpty a -> [a] -> NonEmpty a

-- | Returns a game where the move has not occured and a penalty has been
--   given. Should be used with <tt>doOnly</tt>
illegal :: Int -> String -> Game

-- | A penalty which does not end the turn
penalty :: Int -> String -> Name -> Step

-- | Broadcast a message while identifying the player it came from.
broadcastp :: Name -> String -> Step

-- | Broadcast the message a player sent with their action.
sayAct :: Game

-- | Add a player to the game
addPlayer :: Name -> Maybe (Name, Name) -> Step
addToSeat :: Name -> Maybe (Name, Name) -> [Name] -> [Name]
remPlayer :: Name -> Step

-- | Play a move and tidy up the game state.
play :: Name -> Event -> Card -> Step

-- | The default behaviour. Draws always succeed, a card may be played if
--   it is in the player's hand, it is the player's turn and it matches
--   either the suit or rank of the previous card. Timeouts give one
--   penalty card to the player whose turn it is.
baseAct :: Game

-- | Add a message to the list of messages. Will be seen by all players by
--   default.
broadcast :: String -> Step

-- | Move n cards from the deck to a player's hand
draw :: Int -> Name -> Step

-- | Get the hand of the current player.
getHand :: Name -> GameState -> Maybe Hand

-- | Move a single card from the deck to a player's hand.
draw1 :: Name -> Step

-- | If any players have more than their share of cards, give return them
--   to the deck (so that players can always draw cards and be given
--   penalties).
taxes :: Step

-- | Remove the top card of the deck shuffling the pile back in and
--   applying taxes if necessary.
cardFromDeck :: GameState -> (Card, GameState)

-- | Put a card on the pile
cardToPile :: Card -> Step

-- | Remove a card from a players hand.
cardFromHand' :: Name -> Card -> Step

-- | Test if it is a player's turn.
isTurn :: Name -> GameState -> Bool

-- | Advance the turn order by one.
nextTurn :: Step

-- | incomplete?
win :: Name -> Step

module Game.Bartok.RuleHelpers
when :: (a -> Bool) -> Rule -> a -> Rule
with :: (Event -> GameState -> a) -> (a -> Rule) -> Rule
with' :: (Event -> GameState -> a) -> (a -> Game) -> Game
when' :: (a -> Bool) -> Game -> a -> Game
doAfter :: Game -> Rule
doBefore :: Game -> Rule
doOnly :: Game -> Rule

-- | player's next action must be the given one how do I make require
--   actions for something other than a single
regexProcess :: String -> Regex
split :: String -> [String]
reconstitute :: [String] -> String
findInMs :: String -> String -> Bool
removeIn :: String -> String -> (Bool, String)
removeIn' :: String -> String -> (Maybe String, String)
removeIn'' :: Regex -> [String] -> [String] -> (Maybe String, [String], [String])
removeAll :: String -> String -> ([String], String)
removeAllN :: String -> String -> (Int, String)
removeAll' :: Regex -> ([String], [String]) -> [String] -> ([String], [String])
mustSay :: String -> Game
mustSay' :: String -> Event -> (Event, Step)
said :: String -> String -> Bool
banPhrase :: Int -> String -> ((Name, Action, String) -> GameState -> Bool) -> Rule
require :: (Name, Action, String) -> (Bool -> Game) -> Rule
onPlay :: (Card -> Rule) -> Rule
onLegalCard :: (Card -> Game) -> Rule
onAction :: ((Name, Action, String) -> Rule) -> Rule
onDraw :: ((Name, Int) -> Rule) -> Rule

-- | Advance the turn order by one.
nextTurn :: Step
doNothing :: Step

-- | Returns a game where the move has not occured and a penalty has been
--   given. Should be used with <tt>doOnly</tt>
illegal :: Int -> String -> Game

-- | Add a message to the list of messages. Will be seen by all players by
--   default.
broadcast :: String -> Step

-- | Broadcast a message while identifying the player it came from.
broadcastp :: Name -> String -> Step

-- | A penalty which does not end the turn
penalty :: Int -> String -> Name -> Step

-- | Test if it is a player's turn.
isTurn :: Name -> GameState -> Bool

-- | incomplete?
win :: Name -> Step

-- | Move n cards from the deck to a player's hand
draw :: Int -> Name -> Step

module Game.Bartok.Rules
r8 :: Rule
reverseDirection :: Step
rq :: Rule
rlast :: Rule
rMao :: Rule
(^.^) :: () => (Event -> b -> c) -> (Event -> a -> b) -> Event -> a -> c
(^^.^^) :: () => (Bool -> Event -> b -> c) -> (Bool -> Event -> a -> b) -> Bool -> Event -> a -> c
ifSaid :: String -> Game -> Game
getState :: Event -> GameState -> GameState
rMao'' :: Rule
r7' :: Rule
defaultRules :: [Rule]
defaultRulesNamed :: [([Char], Rule)]


-- | This presents operations with more arguments than strictly necessary
--   so that they can be used interchangeably
module Game.Bartok.TLib

-- | Avoids having to write out extremely long types. Almost a Monad.
type GEGSto a = Game " The inner ruleset" -> Event " The event under consideration" -> GameState " The previous state of the game" -> a

-- | When an action happens, do something with it
withAction :: (Action -> Rule) -> Rule

-- | When an action happens, do something with the message that gets sent
withMessage :: (String -> Rule) -> Rule

-- | When an card is played happens, do something with it
withCard :: (Card -> Rule) -> Rule

-- | When an action happens, do something with the player that made it
withPlayer :: (Name -> Rule) -> Rule

-- | When an action hapens, do something with the hand of the player that
--   made it
withHand :: ([Card] -> Rule) -> Rule

-- | Build a rule (or similar that depends on an extracted value (if you
--   know monads, this is bind <tt>(&gt;&gt;=)</tt>).
--   
--   e.g. <tt>with (<a>getVar</a> "n") ( n -&gt;
--   doSomethingInvolvingN)</tt>
--   
--   e.g. &gt; with (<a>getVar</a> "n") ( n -&gt; doSomethingInvolvingN)
with :: GEGSto a -> (a -> GEGSto b) -> GEGSto b

-- | Given a condition, implement a rule only when that condition holds.
when :: GEGSto Bool -> Rule -> Rule

-- | Given a condition, do one thing when the condition holds and another
--   when it doesn't.
whether :: GEGSto Bool -> Rule -> Rule -> Rule

-- | Given a fresh variable name, when a condition is met, run an action on
--   the following turn.
onNextTurn :: VarName -> GEGSto Bool -> Rule -> Rule

-- | Upon a condition being satisfied, implement a rule until a second
--   condition is satisfied.
uponDoUntil :: VarName -> GEGSto Bool -> Rule -> GEGSto Bool -> Rule

-- | lift an action (monadic <a>fmap</a>)
(.:) :: (a -> b) -> GEGSto a -> GEGSto b

-- | Abbreviation for _ _ _ -&gt;
__ :: a -> GEGSto a

-- | Returns True if the event is an Action.
isAction :: GEGSto Bool

-- | Returns True if the event is an action and is legal under the inner
--   ruleset.
isLegal :: GEGSto Bool

-- | Returns True if the event is an action and the next Turn should be
--   taken by the player submitting it.
isTurn :: GEGSto Bool

-- | Returns True if the event is an action which satisfies the condition.
actionIs :: (Action -> Bool) -> GEGSto Bool

-- | Returns True if the event is a Play action and the card satisfies the
--   condition.
cardIs :: (Card -> Bool) -> GEGSto Bool

-- | Returns True if the value of the named variable is not 0.
boolVar :: VarName -> GEGSto Bool

-- | Tests if a player said something matching a given regex (case
--   insenstive). Like most string processing functions in this project,
--   this separates input messages based on semicolons.
said :: String -> GEGSto Bool

-- | Combines 2 tests. Returns True if both do.
(~&~) :: GEGSto Bool -> GEGSto Bool -> GEGSto Bool

-- | Negates a test. Be aware that <tt>(not_ (actionIs (==(Draw 2))))</tt>
--   is different from <tt>(actionIs (/=(Draw 2)))</tt>. The first example
--   would return True for events that are not actions.
not_ :: GEGSto Bool -> GEGSto Bool

-- | Retrive a variable from the GameState.
getVar :: String -> GEGSto Int

-- | Extract the state argument.
state :: GEGSto GameState

-- | The penalty message produced by <tt>mustSay s</tt>
mkFailMsg :: String -> String

-- | penalize if <tt>s</tt> is not said
mustSay :: String -> Rule

-- | Penalize for unnecessarily saying something. This works by testing if
--   the absence of any matching component of a player's message would
--   cause a penalty containing <tt>failmsg</tt>. If not, the component is
--   assumed to be unnecessary.
unnec :: String -> Rule

-- | If the condition holds, require that they say the message; otherwise,
--   penalize them if they say it
sometimesSay :: String -> GEGSto Bool -> Rule

-- | Any action except the specified one is an illegal move. When the
--   specified action occurs, run the second argument.
mustDo :: Action -> Rule -> Rule

-- | Like <a>mustSay</a>, but with custom penalty message
mustSayPenalty :: String -> String -> Rule
sometimesSayPenalty :: String -> GEGSto Bool -> String -> String -> Rule
unnecPenalty :: String -> (String -> String) -> Rule

-- | Transform the list of players (affects turn order).
modifyPlayers :: ([Name] -> [Name]) -> Step

-- | Transform the message that gets sent
modifyMessage :: (String -> String) -> Rule

-- | Award a penalty to the acting player without preventing their action.
penalty :: Int -> String -> Game

-- | A class for types that are <tt>smaller</tt> than <a>Rule</a> so that
--   there are different options for how to convert.
class Ruleable a
doAfter :: Ruleable a => a -> Rule
doBefore :: Ruleable a => a -> Rule
doOnly :: Ruleable a => a -> Rule

-- | The type of transformations of game state
type Step = GameState -> GameState

-- | This is the type of games (meaning a ruleset, rather than a specific
--   instance of a game). Given an event such as a player action, and a
--   game state, it returns the resulting state
type Game = Event -> Step

-- | The type of rules - a rule is added by function composition forming a
--   chain such as 'r3 (r1 (r2 baseAct))' . Most rules should call the
--   first argument under most circumstances and usually without changing
--   the event.
--   
--   Game -&gt; Game == (Event -&gt; GameState -&gt; GameState) -&gt; Event
--   -&gt; GameState -&gt; GameState
type Rule = Game -> Game

-- | The state of a game in play
data GameState

-- | Events that rules should be able to deal with
data Event

-- | A player leaving the game
PlayerLeave :: Name -> Event

-- | A player requesting to join the game. This is not limited to the start
PlayerJoin :: Name -> Maybe (Name, Name) -> Event

-- | A player performing one of the above actions and sending a message.
Action :: Name -> Action -> String -> Event

-- | If no player has made an action for 10 seconds, this event will be
--   sent
Timeout :: Event

-- | At any point, a player can attempt to take one of these actions
data Action
Draw :: Int -> Action
Play :: Card -> Action

-- | Names of players.
type Name = String

-- | A single playing card
type Card = (Rank, Suit)

-- | A card as viewed - the type of cards sent to the client
data CardView
CardFace :: Card -> CardView
CardBack :: CardView

-- | The structure describing data seen by players
data GameView
GV :: [(Name, [CardView])] -> [CardView] -> [CardView] -> [String] -> GameView

-- | The players and the information a particular player will have about
--   each hand. By default, this is a <a>CardFace</a>s for the viewing
--   player and a number of <a>CardBack</a>s for others.
[_handsV] :: GameView -> [(Name, [CardView])]

-- | What should be seen of the pile. By default, only the top card is
--   visible.
[_pileV] :: GameView -> [CardView]

-- | What should be seen of the pile. By default, none are visible.
[_deckV] :: GameView -> [CardView]

-- | The messages a player can see. By default, this is all messages that
--   have been sent
[_messagesV] :: GameView -> [String]

-- | Get the suit of a card.
suit :: Card -> Suit

-- | Get the rank of a card.
rank :: Card -> Rank
data Suit
Clubs :: Suit
Diamonds :: Suit
Hearts :: Suit
Spades :: Suit
data Rank
Ace :: Rank
Two :: Rank
Three :: Rank
Four :: Rank
Five :: Rank
Six :: Rank
Seven :: Rank
Eight :: Rank
Nine :: Rank
Ten :: Rank
Jack :: Rank
Knight :: Rank
Queen :: Rank
King :: Rank

-- | Functions to tell a player what they should see
type Viewer = Name -> GameState -> GameView

-- | Rules that modify what players see without affecting the game state
type ViewRule = Viewer -> Viewer

-- | variable processing
readVar :: VarName -> GameState -> Int
setVar :: VarName -> Int -> Step
modifyVar :: VarName -> (Int -> Int) -> Step

-- | Advance the turn order by one.
nextTurn :: Step

-- | Move n cards from the deck to a player's hand
draw :: Int -> Name -> Step

-- | Add a message to the list of messages. Will be seen by all players by
--   default.
broadcast :: String -> Step
(%) :: String -> String -> String

-- | Modify all cards in the game
mapAllCards :: (Card -> Card) -> GameState -> GameState
instance Game.Bartok.TLib.Ruleable Game.Bartok.DataTypes.Step
instance Game.Bartok.TLib.Ruleable Game.Bartok.DataTypes.Game


-- | The functions in this module define how the data sent to clients is
--   constructed. They should help when writing rules that affect what
--   players can see.
module Game.Bartok.Views

-- | Functions to tell a player what they should see
type Viewer = Name -> GameState -> GameView

-- | Rules that modify what players see without affecting the game state
type ViewRule = Viewer -> Viewer

-- | Like <tt>baseGame</tt>, this defines how cards should be viewed in a
--   very simple game. See <a>GameView</a> for more.
baseViewer :: Viewer

-- | The structure describing data seen by players
data GameView
GV :: [(Name, [CardView])] -> [CardView] -> [CardView] -> [String] -> GameView

-- | The players and the information a particular player will have about
--   each hand. By default, this is a <a>CardFace</a>s for the viewing
--   player and a number of <a>CardBack</a>s for others.
[_handsV] :: GameView -> [(Name, [CardView])]

-- | What should be seen of the pile. By default, only the top card is
--   visible.
[_pileV] :: GameView -> [CardView]

-- | What should be seen of the pile. By default, none are visible.
[_deckV] :: GameView -> [CardView]

-- | The messages a player can see. By default, this is all messages that
--   have been sent
[_messagesV] :: GameView -> [String]

-- | Hide the last card in a player's hand.
lastCard :: ViewRule

-- | Hides other players' hands.
onlyOwnCards :: ViewRule

-- | <tt>baseView</tt> with the above rules added to it.
defaultView :: Viewer

-- | Turn a function transforming a <a>GameView</a> into a viewRule &gt;
--   makeViewTransformer f r p gs == f$ r p gs
makeViewTransformer :: (GameView -> GameView) -> ViewRule

-- | Modify a player's view of their own hand
mapOwnHand :: ([CardView] -> [CardView]) -> ViewRule

-- | Modify the view of all other players' hands
mapOtherHands :: ([CardView] -> [CardView]) -> ViewRule

-- | Apply a modification to the structure describing what can be seen of
--   each player's hand after inner rules have been applied.
modifyHandMap :: ([(Name, [CardView])] -> [(Name, [CardView])]) -> ViewRule

-- | Apply a function to all views of hands
mapHands :: ([CardView] -> [CardView]) -> ViewRule
hideHand :: [CardView] -> [CardView]


-- | Looking at the source code is recommended
module Game.Bartok.TSample
r7 :: Rule
r8 :: Rule
rq :: Rule
rSpade :: Rule


-- | Look at the implementation of these to see examples of how to write
--   rules
module Game.Bartok.Sample

-- | When an 8 is played, skip the following player's turn
r8 :: Rule
reverseDirection :: Step

-- | Reverse direction when a Queen is played
rq :: Rule
mustdo7 :: Int -> (Bool -> Game) -> Rule
count7s :: GameState -> Int

-- | When a seven is played, the player must say 'have a nice day'. The
--   following player must either play another seven, saying 'have a very
--   nice day' or say 'thank you' and draw 2 cards. If futher sevens are
--   played (each such player must add another <tt>very</tt>), the first
--   player who cannot play one must say 'thank you very{n} much' and draw
--   2n cards.
r7 :: Rule
r7' :: Rule
rC :: Game -> Game
gSnap :: Rule'
nextTurnDo :: String -> (Game -> Event -> GameState -> Bool) -> Rule -> Rule
nextTurnDoUntil :: String -> (Game -> Event -> GameState -> Bool) -> (Game -> Event -> GameState -> (GameState, Bool)) -> Rule
r6 :: Rule
rPM :: Rule
rPMV :: ViewRule
rPM' :: Rule'
rBlind :: Rule
rBlindV :: ViewRule
rBlind' :: Rule'
run7 :: Int -> Rule
rKnight :: Rule
rbadger :: (Event -> GameState -> GameState) -> Event -> GameState -> GameState

-- | When a four is played, toggle complete visibility
rFourShow :: Rule'
